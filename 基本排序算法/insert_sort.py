"""
每一轮保证前面的都已排序，然后把其后的一个插入到合适的位置即可
写起来稍微复杂
"""
def insertSort(lst):
	i=0
	while(i<len(lst)-1):#在这一轮要把第i+1个插入0-i的有序队列中
		j=0
		while j<=i:
			if(lst[i+1]<lst[j]):#找到插入点，把lst[i+1]放在j的位置，然后把原j到i的顺移到j+1到i+1
				temp=lst[i+1]
				k = i
				while (k>=j):
					lst[k+1]=lst[k]
					k-=1
				lst[j]=temp
			j+=1
		#print(i,lst)
		i+=1

lst = [3, 5,4, 6,9, 2, 3, 7]

insertSort(lst)
print(lst)

"""
比较书上的写法，比我高明太多。
我是将带插入的元素依次与前面的元素从前到后比较，一旦插入元素小于当前元素（能来到这里自然默认地大于前一个元素），插入位置就确定下来后，最后的插入通过"三角"倒换来实现。

而书上是：
从后到前的比较，一旦插入元素小于当前元素，插入具体位置还不能确定（还要看是否大于前一个元素），看可以确定插入位置肯定是当前或者再往前，于是可以把当前元素往后挪一位。由于从后开始，不用担心后面一位的值被覆盖，因此在此之前已经被挪走了。

"""

def insertSort(lst):
	i=0
	while(i<len(lst)-1):#在这一轮要把第i+1个插入0-i的有序队列中
		j=i
		temp = lst[i + 1]#必须把第i+1个元素的值保存出来，否则每次满足if就会被覆盖
		while j>=0:

			if(temp<lst[j]):#找到插入点，把lst[i+1]放在j的位置，然后把原j到i的顺移到j+1到i+1

				lst[j+1]=lst[j]
				j-=1
			else:
				break
		#至此插入点才确定
		lst[j+1]=temp
		i+=1

lst = [3, 5,4, 6,9, 2, 3, 7]

insertSort(lst)
print(lst)
""""
有点麻烦，改了一会儿才改对

复杂度：
外层n-1轮循环，内层要看情况
如果最坏，所有数据未排序，那么是1+2+……+（n-1),复杂度是n的平方
如果最好，所有数据已排序，内层循环的第一轮就会执行else break，也就是内层只执行1轮，一共就是外层的n-1次循环，所以总体是线性的。
如果是普通情况，复杂度介于两者之间，仍然是n的平方次阶

"""